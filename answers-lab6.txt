1. How did you structure your transmit implementation? 
   In particular, what do you do if the transmit ring is full?

We handle enqueuing of up to 16 packets for transmission.
The descriptor array and packet buffer pointer array are global variables, but
the packet buffer pointer array contents are initialized to NULL,
as well as the address value at the corresponding descriptor, since
we implemented zero-copy driver, and will get the correct address
from the output env.
Each packet buffer fits the size equal to PGSIZE and aligned to a single page
in order to support zero-copy implementation.
The exact explanation of zero-copy implementation of receive and transmit 
will be given at the challange descriptions.
On e1000_attach we mark all the cells in the TX desriptor as free 
for use by our driver, by turning on the DD bit. 
We also setup the Transmit Interrupt Delay Value (TIDV) to 10 micro-seconds
and enable the TXDW (transmit-complete interrupt) by masking it at the 
IMS register, in order to handle the case of putting the output env to sleep 
while the transmit ring is full, and wake it up by the TXDW interrupt,
as will be explained below.
Next, we enable interrupts from the E1000 NIC and agree on an irq_line.

When the transmit ring is full, on the network driver, in kernel,
we set the output env status to a new status: ENV_WAITING_FOR_IO
instead of ENV_RUNNING, which suspends the execution of the enviorment,
while also ensuring that the operating system doesn't terminate
when all existing envs are in that state,
since they are still expected to finish their operation.

also, we mark the flag env_waits_for_output as true and then
go back to user space.
In user space, upon receiving a packet via ipc_recv,
the output env will try to transmit the packet in a while loop,
until it succeeds or gets an error which is not -E_AGAIN,

Upon TXDW interrupt, the handler will search for an env marked as 
ENV_WAITING_FOR_IO and also env_waits_for_output and will change the
values back to ENV_RUNNABLE and false respectivly,
so the scheduler will eventually
wake the output env to transmit the packet successfuly.
the observed return value is -E_AGAIN,
which signals to the env that is should attempt to transmit the packet again,
now that the queue isn't full.


2. How did you structure your receive implementation? In particular, 
what do you do if the receive queue is empty and a user environment 
requests the next incoming packet?

We handle enqueuing of up to 128 packets for reception.
The packet buffer characteristics are the same,
as described in transmission above, except here,
in e1000_attach we allocate 128 new pages and update its address
at each corresponding decriptor in order to allow the E1000
NIC to write to them by DMA upon receiving.
In addition, we mark all the cells in the RX desriptor as empty
by turning off the DD bit. 
We also enable the RXT0 (Receiver Timer Interrupt) 
by masking it at the IMS register, to receive this interrupt.

In user space,
the input env will try to receive a packet in a while loop,
using the syscall for receiving packets,
until it succeeds or gets an error which is not -E_AGAIN.

When the transmit ring is empty, we set the input env status to 
ENV_WAITING_FOR_IO instead of ENV_RUNNING,
also, we mark the flag env_waits_for_input as true and then
go back to user space.

Upon RXT0 interrupt, the handler will search for an env marked as 
ENV_WAITING_FOR_IO and also env_waits_for_input and will change the
values back to ENV_RUNNABLE and false respectivly,
so the scheduler will eventually wake the input env.
the observed return value is -E_AGAIN,
which signals to the env that is should attempt to receive a packet again,
now that the queue isn't empty.

3. What does the web page served by JOS's web server say?

This file came from JOS.
Cheesy web page!

4. How long approximately did it take you to do this lab?

~ 200 hours

*********************** CHALLANGES *******************

1) Challange: 

Modify your E1000 driver to be "zero copy."

Explanation:

In order to suppport zero-copy, we use a whole page for each packet
so we can transfer packets by simply mapping them to different address spaces.
The max packet size of 2096 bytes assures it will fit a single page. 
We used the ipc mechanism which supports exactly this kind of behavior.
Since the network stack uses the start of the page for the buffer length,
this layout is also used by the driver so that the pages could be used as is.


On transmission, the network stack sends the page containing the packet,
to the output env via ipc_send.
Next, we pass this page to the e1000 driver, in which we do the following:
- we decrement the refcount of the page in the packet buffer array,
  matching the tail of the transmission queue, if there was such a page,
  so that it could be recycled if no other env is using it.
- we place the new page in the array at the same position.
- we update the physical address and length stored at said descriptor,
  to match new page, and increment its pages refcount.
  so it won't be prematurly recycled if its unmapped in userspace.
- we increment the tail so that the packet can transfered to the NIC via DMA.


On reception, at setup of the driver, we allocate in advance all
128 pages and update each descriptor address value,
to hold the physical addresses corresponding to each page.
When a packet is received by the NIC,
while the input env is waiting for a packet, we do the following:
- write the packet length from the descriptor to the beginning
  of the corresponding page.
- map the page containing the received packet to the input env at
  its chosen virtual address.
- decrease the ref count of the mapped page so when user unmaps it, it
  will get recycled.
- allocate a new page and update the descriptor,
  and reception packet buffer array to point to the new page.

it should be noted that both reception and transmission
did not involve copying the packets, but instead used memory mapping,
to acomplish said tasks.


2) Challange: 

Write the code to load the E1000's MAC address out of the EEPROM

Explanation:

3) Challange: 

Add a simple chat server to JOS

Explanation: