1. How did you structure your transmit implementation? 
   In particular, what do you do if the transmit ring is full?

We handle enqueuing of up to 16 packets for transmission.
The descriptor array and packet buffers pointer array are global variables, but
the packet buffer pointers array cell contents are initialized to NULL,
as well as the address value at the corresponding descriptor, since
we implemented zero-copy driver, and will get the correct address
from the output env.
Each packet buffer fits the size equal to PGSIZE and aligned to a single page
in order to support zero-copy implementation.
The exact explanation of zero-copy implementation of receive and transmit 
will be given at the challange descriptions.
On e1000_attach we mark all the cells in the TX desriptor as free 
for use by our driver, by turning on the DD bit. 
We also setup the Transmit Interrupt Delay Value (TIDV) to 10 micro-seconds
and enable the TXDW (transmit-complete interrupt) by masking it at the 
IMS register, in order to handle the case of putting the output env to sleep 
while the transmit ring is full, and wake it up by the TXDW interrupt,
as will be explained below.
Next, we enable interrupts from the E1000 NIC and agree on an irq_line.

When the transmit ring is full, on the network driver, in kernel,
we set the output env status to a new status: ENV_WAITING_FOR_IO
instead of ENV_RUNNING, which suspends the execution of the enviorment,
while also ensuring that the operating system doesn't terminate
when all existing envs are in that state,
since they are still expected to finish their operation.

also, we mark the flag env_waits_for_output as true and then
go back to user space.
In user space, upon receiving a packet via ipc_recv,
the output env will try to transmit the packet in a while loop,
until it succeeds or gets an error which is not -E_AGAIN,

Upon TXDW interrupt, the handler will search for an env marked as 
ENV_WAITING_FOR_IO and also env_waits_for_output and will change the
values back to ENV_RUNNABLE and false respectivly,
so the scheduler will eventually
wake the output env to transmit the packet successfuly.
the observed return value is -E_AGAIN,
which signals to the env that is should attempt to transmit the packet again,
now that the queue isn't full.


2. How did you structure your receive implementation? In particular, 
what do you do if the receive queue is empty and a user environment 
requests the next incoming packet?

We handle enqueuing of up to 128 packets for reception.
The packet buffer characteristics are the same as described in transmission above,
except here, in e1000_attach we allocate 128 new pages and update its address
at each corresponding decriptor in order to allow the E1000
NIC to write to them by DMA upon receiving.
In addition, we mark all the cells in the RX desriptor as empty
by turning off the DD bit. 
We also enable the RXT0 (Receiver Timer Interrupt) 
by masking it at the IMS register, to receive this interrupt.

In user space,
the input env will try to receive a packet in a while loop,
using the syscall for receiving packets,
until it succeeds or gets an error which is not -E_AGAIN.

When the transmit ring is empty, we set the input env status to 
ENV_WAITING_FOR_IO instead of ENV_RUNNING,
also, we mark the flag env_waits_for_input as true and then
go back to user space.

Upon RXT0 interrupt, the handler will search for an env marked as 
ENV_WAITING_FOR_IO and also env_waits_for_input and will change the
values back to ENV_RUNNABLE and false respectivly,
so the scheduler will eventually wake the input env.
the observed return value is -E_AGAIN,
which signals to the env that is should attempt to receive a packet again,
now that the queue isn't empty.

3. What does the web page served by JOS's web server say?

This file came from JOS.
Cheesy web page!

4. How long approximately did it take you to do this lab?

~ 200 hours

*********************** CHALLANGES *******************

1) Challange: 

Modify your E1000 driver to be "zero copy."

Explanation:

In order to suppport zero-copy, we had to modify packets to fit
a whole page, so we can simply map the physical page containing 
the packet length and data to a virtual page at user/kernel space.
So the packet buffer pointers array is actually array of struct PageInfo *.
The max packet size of 2096 bytes assures it will fit a single page. 
We used the ipc mechanism which supports exactly this kind of behavior.


On transmission, the output env uses ipc_recv with the address of nsipcbuf,
as the virtual page address it wants to map the received packet to.
nsipcbuf is of type jif_pkt, in correspondence to the structure
of the sent packet.
To send a packet to the output env, the network server will use 
ipc_send with the address of the page containing the pkt,
So the kernel will map the physical page contains the
pkt to the virtual address of output env at nsipcbuf.
Next, we transmit this packet (as an address and length) to the e1000 driver,
there, at function transmit_packet we do the following:
- if the address of the corresponding index of tail at the packet buffer
pointer array is not NULL (contained a packet which was already sent),
we decrease the ref count of this page in order to be able to recycle it later,
in case it was unmapped by the user env.
- we update the pointer to point to the page mapped at output env pgdir
for the packet at VA given as an argument,
and increase it's ref count so it won't be recycled in case
it's unmapped by the user,
until it is sent by the NIC and we decrese the ref count at the above action.
- we update the corresponding descriptor to hold the physical address of the
the page, starting from the offset to the data.

This way, we avoid copying the actual packet content by exploiting the
advantages of virtualization.


On reception, at setup of the driver, we allocate in advance all
128 pages and update the corresponding descriptor addr value to hold the
physical address of the page starting at offset of the data, which is
of sizeof(int) since jif_pkt contains the length attribute at the beginning.
Upon receiving a packet, the NIC will write the data to the physical page pointed
by the descriptor and the metadata to the descriptor using DMA.
The input env calls receive_packet implicitly by syscall with the address
of its nsipcbuf as an argument.
at function receive_packet we do the following in case of available packet:
- write the packet length from the descriptor to the beginning
of the corresponding page.
- map the received page containing the packet to the input env pgdir at
the given VA, received as an argument.
- decrease the ref count of the mapped page so when user unmaps it, it
will get recycled.
- allocate a new page and update the packet buffer pointer and descriptor
to the new page address.

Here also, we didn't copy the data but mapped it's physical page
to input env's virtual address instead.




2) Challange: 

Write the code to load the E1000's MAC address out of the EEPROM

Explanation:

3) Challange: 

Add a simple chat server to JOS

Explanation: